package generator

import (
	"bytes"
	"fmt"
	"go/types"
	"io"
	"strings"

	"github.com/bongnv/noopgen/logger"
	"golang.org/x/tools/imports"
)

const (
	logTag = "generator"
)

// Command ...
type Command struct {
	InterfaceName string
	NoopName      string
	FileName      string
	IFaceType     *types.Interface
	Out           io.Writer
	PackageName   string

	importMap map[string]*types.Package
	buf       *bytes.Buffer
}

func Process(cmd *Command) error {
	cmd.buf = &bytes.Buffer{}

	steps := []func(*Command) error{
		populatePackages,
		populateImports,
		populateStruct,
		populateStructImplementations,
		goImportsAndPrintOut,
	}

	for _, fn := range steps {
		if err := fn(cmd); err != nil {
			return err
		}
	}

	return nil
}

func populateStruct(cmd *Command) error {
	fmt.Fprintf(cmd.buf,
		"// %s is an autogenerated noop implementation for the %s.\n",
		cmd.NoopName,
		cmd.InterfaceName,
	)

	fmt.Fprintf(cmd.buf,
		"type %s struct {}\n",
		cmd.NoopName,
	)
	return nil
}

// getTypeName returns name from a type.
func getTypeName(t types.Type) string {
	switch typ := t.(type) {
	case *types.Named:
		o := typ.Obj()
		pkg := o.Pkg()
		if pkg == nil {
			return o.Name()
		}

		return pkg.Name() + "." + o.Name()
	case *types.Pointer:
		return "*" + getTypeName(typ.Elem())
	case *types.Interface:
		logger.Info(logTag, "Got an interface, trying to its name: %v", typ)
		return typ.String()
	case *types.Basic:
		return typ.String()
	default:
		logger.Info(logTag, "Undefined type: %v", typ)
		return typ.String()
	}
}

func generateParamsFromTuple(tup *types.Tuple) string {
	vars := []string{}
	for i := 0; i < tup.Len(); i++ {
		v := tup.At(i)
		vars = append(vars, "_ "+getTypeName(v.Type()))
	}

	return strings.Join(vars, ", ")
}

func generateResultsFromTuple(tup *types.Tuple) string {
	vars := []string{}
	for i := 0; i < tup.Len(); i++ {
		v := tup.At(i)
		vars = append(vars, getTypeName(v.Type()))
	}

	if len(vars) == 0 {
		return ""
	}

	if len(vars) == 1 {
		return vars[0]
	}

	return strings.Join(vars, ", ")
}

func getDefaultValue(t types.Type) string {
	switch typ := t.(type) {
	case *types.Pointer:
		return "nil"
	case *types.Interface:
		return "nil"
	case *types.Named:
		logger.Info(logTag, "Undefined type: %v, underlying: %v", typ, typ.Underlying())
		if typ.String() == "error" {
			return "errors.New(\"noop: no operation\")"
		}
		return "nil"
	case *types.Basic:
		if typ.Info()&types.IsNumeric > 0 {
			return "0"
		}

		if typ.Info() == types.IsBoolean {
			return "false"
		}

		return `""`
	default:
		logger.Info(logTag, "Undefined type: %v, underlying: %v", typ, typ.Underlying())
		return typ.String()
	}
}

func generateReturnFromTuple(tup *types.Tuple) string {
	rets := []string{}
	for i := 0; i < tup.Len(); i++ {
		v := tup.At(i)
		rets = append(rets, getDefaultValue(v.Type()))
	}

	if len(rets) == 0 {
		return ""
	}

	return "return " + strings.Join(rets, ", ")
}

func populateStructImplementations(cmd *Command) error {
	for i := 0; i < cmd.IFaceType.NumMethods(); i++ {
		m := cmd.IFaceType.Method(i)
		mSig := m.Type().(*types.Signature)
		mName := m.Name()

		fmt.Fprintf(cmd.buf,
			"// %s ...\n",
			mName,
		)

		params := generateParamsFromTuple(mSig.Params())
		results := generateResultsFromTuple(mSig.Results())
		returns := generateReturnFromTuple(mSig.Results())

		fmt.Fprintf(cmd.buf,
			"func (_ *%s) %s(%s) (%s) {\n",
			cmd.NoopName,
			mName,
			params,
			results,
		)

		fmt.Fprintf(cmd.buf, returns+"\n")
		fmt.Fprintf(cmd.buf, "}\n")
	}

	return nil
}

func goImportsAndPrintOut(cmd *Command) error {
	logger.Info("generator", "Generated: %v", cmd.buf.String())
	out, err := imports.Process("", cmd.buf.Bytes(), nil)
	if err != nil {
		return err
	}
	cmd.Out.Write(out)
	return nil
}

// TODO
func populatePackages(cmd *Command) error {
	fmt.Fprintf(cmd.buf, "// Code generated by noopgen v0.0.1. DO NOT EDIT.\n\n")
	fmt.Fprintf(cmd.buf, "package %s\n", cmd.PackageName)
	return nil
}

func populateImports(cmd *Command) error {
	cmd.importMap = map[string]*types.Package{}
	for i := 0; i < cmd.IFaceType.NumMethods(); i++ {
		m := cmd.IFaceType.Method(i)
		mType := m.Type().(*types.Signature)
		if err := analyzeImportsFromTuple(cmd, mType.Params()); err != nil {
			return err
		}

		if err := analyzeImportsFromTuple(cmd, mType.Results()); err != nil {
			return err
		}
	}

	if len(cmd.importMap) == 0 {
		return nil
	}

	fmt.Fprintln(cmd.buf, "import (")
	fmt.Fprintln(cmd.buf, "\"errors\"")
	for path := range cmd.importMap {
		fmt.Fprintf(cmd.buf, "\"%s\"\n", path)
	}
	fmt.Fprintln(cmd.buf, ")")
	return nil
}

func analyzeImportsFromTuple(cmd *Command, tuple *types.Tuple) error {
	for i := 0; i < tuple.Len(); i++ {
		if err := populateImportForType(cmd, tuple.At(i).Type()); err != nil {
			return err
		}
	}

	return nil
}

func populateImportsForPkg(cmd *Command, pkg *types.Package) error {
	if pkg == nil {
		return nil
	}

	if _, ok := cmd.importMap[pkg.Path()]; ok {
		return nil
	}

	cmd.importMap[pkg.Path()] = pkg
	return nil
}

func populateImportForType(cmd *Command, t types.Type) error {
	switch typ := t.(type) {
	case *types.Named:
		o := typ.Obj()
		return populateImportsForPkg(cmd, o.Pkg())
	case *types.Pointer:
		return populateImportForType(cmd, typ.Elem())
	case *types.Slice:
		return populateImportForType(cmd, typ.Elem())
	case *types.Array:
		return populateImportForType(cmd, typ.Elem())
	case *types.Map:
		if err := populateImportForType(cmd, typ.Key()); err != nil {
			return err
		}
		if err := populateImportForType(cmd, typ.Elem()); err != nil {
			return err
		}
		return nil
	case *types.Chan:
		populateImportForType(cmd, typ.Elem())
		//default:
		//	panic(fmt.Sprintf("un-namable type: %#v (%T)", t, t))
	}

	return nil
}
